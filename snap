#!/usr/bin/perl

$pi = 4 * atan2(1, 1);
$foot = .00000274;
$bucket = 50 * $foot;

open(IN, "../city.snap");
while (<IN>) {
	chomp;
	if (/\/\/ id=([0-9]*)/) {
		$id = $1;
	} else {
		print STDERR "no id in $_\n";
		next;
	}

	next unless /;highway=/;

	if (/;oneway=([^ ;]*)/) {
		$oneway{$id} = $1;
	} else {
		$oneway{$id} = "unknown";
	}

	if ($seq++ % 100 == 0) {
		print STDERR "$id\r";
	}

	s/ *\/\/.*//;
	@points = split(/ /);
	@lat = ();
	@lon = ();

	for $p (@points) {
		($lat, $lon) = split(/,/, $p);

		if ($rat == 0) {
			$rat = cos($lat * $pi / 180);
			# print STDERR "rat is $rat\n";
		}

		push @lat, $lat;
		push @lon, $lon;
	}

	@lat2 = ();
	@lon2 = ();

	for ($i = 0; $i < $#lat; $i++) {
		push @lat2, $lat[$i];
		push @lon2, $lon[$i];

		$latd = ($lat[$i + 1] - $lat[$i]);
		$lond = ($lon[$i + 1] - $lon[$i]) * $rat;
		$d = sqrt($latd * $latd + $lond * $lond);

		if ($d > $bucket) {
			# print STDERR "too far $d between $lat[$i],$lon[$i] and $lat[$i + 1],$lon[$i + 1]\n";

			$n = int($d / $bucket) + 1;
			for ($j = 1; $j < $n; $j++) {
				$lat = $lat[$i] * (1 - ($j / $n)) + $lat[$i + 1] * (($j / $n));
				$lon = $lon[$i] * (1 - ($j / $n)) + $lon[$i + 1] * (($j / $n));

				# print STDERR "interpolate $lat,$lon  $j of $n\n";

				push @lat2, $lat;
				push @lon2, $lon;
			}
		}
	}

	push @lat2, $lat[$#lat];
	push @lon2, $lon[$#lon];

	@{$lats{$id}} = @lat2;
	@{$lons{$id}} = @lon2;

	for ($i = 0; $i < $#lat2; $i++) {
		$lat = ($lat2[$i] + $lat2[$i + 1]) / 2;
		$lon = ($lon2[$i] + $lon2[$i + 1]) / 2;

		$a = int($lat / $bucket);
		$o = int($lon * $rat / $bucket);

		push @{$ways{$a}{$o}}, "$id $i";
	}
}

# probably adpated from http://paulbourke.net/geometry/pointlineplane/DistancePoint.java ?
sub distanceAlongSegment {
        my ($p1x, $p1y, $p2x, $p2y, $p3x, $p3y) = @_;

        my $xDelta = $p2x - $p1x;
        my $yDelta = $p2y - $p1y;

	if ($xDelta * $xDelta + $yDelta * $yDelta == 0) {
		return -1;
	}

        my $u = (($p3x - $p1x) * $xDelta + ($p3y - $p1y) * $yDelta) / ($xDelta * $xDelta + $yDelta * $yDelta);

        return $u;
}

while (<>) {
	chomp;
	($lat, $lon) = split(/[, ]/);

	$a = int($lat / $bucket);
	$o = int($lon * $rat / $bucket);

	print "$lat,$lon: ";

	@possible = ();
	for ($aa = $a - 1; $aa <= $a + 1; $aa++) {
		for ($oo = $o - 1; $oo <= $o + 1; $oo++) {
			push @possible, @{$ways{$aa}{$oo}};
		}
	}

	$bestd = 99999;
	$best = "xxx xxx unknown xxx,xxx";
	$bestway = 0;

	$samed = 99999;
	$same = "xxx xxx unknown xxx,xxx";
	$sameway = 0;

	for $p (@possible) {
		($way, $seg) = split(/ /, $p);
		$along = distanceAlongSegment($lats{$way}[$seg], $lons{$way}[$seg],
		                              $lats{$way}[$seg + 1], $lons{$way}[$seg + 1],
					      $lat, $lon);
		if ($along < 0) {
			$along = 0;
		}
		if ($along > 1) {
			$along = 1;
		}

		$lat1 = $lats{$way}[$seg + 1] * $along + $lats{$way}[$seg] * (1 - $along);
		$lon1 = $lons{$way}[$seg + 1] * $along + $lons{$way}[$seg] * (1 - $along);

		$latd = ($lat - $lat1);
		$lond = ($lon - $lon1) * $rat;
		$d = sqrt($latd * $latd + $lond * $lond);

		if ($d < $bucket) {
			if ($d < $bestd) {
				$bestd = $d;
				$bestway = $way;
				$best = "$way " . sprintf("%.4f", $seg + $along) . " $oneway{$way} $lat1,$lon1";
			}

			if ($d < $samed && $way == $prevway) {
				$samed = $d;
				$sameway = $way;
				$same = "$way " . sprintf("%.4f", $seg + $along) . " $oneway{$way} $lat1,$lon1";
			}
		}
	}

	if ($sameway != 0) {
		$bestd = $samed;
		$best = $same;
		$bestway = $sameway;
	}

	printf("%.2f ", $bestd / $foot);
	print "$best\n";

	$prevway = $bestway;
}
